#pragma once#include <cstdlib>#include <cfloat>#include <cmath>#include <iostream>#include <list>#include <vector>#include <itpp/itbase.h>#include <itpp/signal/fastica.h>#include <boost/lexical_cast.hpp>#include <boost/numeric/ublas/io.hpp>#include <boost/numeric/ublas/matrix.hpp>#include <boost/numeric/ublas/matrix_proxy.hpp>#include <boost/numeric/ublas/vector.hpp>#include "rnd_shuffle.h"#define STANDARD_K_MEANS 1#define K_MEANS_PLAS_PLAS 2#define K_MEANS_USE_ICA 3using namespace std;using namespace itpp;using namespace boost;using namespace boost::numeric::ublas;typedef matrix<double> dmat;typedef matrix_row<dmat> dmat_r;typedef boost::numeric::ublas::vector<double> boost_dvect;typedef list<double> dlist;typedef std::vector<boost_dvect> stl_dvvect;mat boost_mat_2_itpp_mat(dmat);dmat itpp_mat_2_boost_mat(mat);stl_dvvect kmeans(int , dmat*, int);void choose_random_center(int, stl_dvvect*, dmat*);void choose_smart_center(int, stl_dvvect*, dmat*);void choose_ica_center(int, stl_dvvect*, dmat*);void classification(int, stl_dvvect*, dmat*);//Convertermat boost_mat_2_itpp_mat(dmat mat_boost){  mat mat_itpp((int)mat_boost.size1(), (int)mat_boost.size2());  for(int i = 0; i < (int)mat_boost.size1(); ++i){    string str = "";    for(int j = 0; j < (int) mat_boost.size2(); ++j){      str += lexical_cast<string>(mat_boost(i, j)) + " ";    }    mat_itpp.set_row(i, str);  }  return mat_itpp;}dmat itpp_mat_2_boost_mat(mat mat_itpp){  dmat mat_boost((int)mat_itpp.rows(), (int)mat_itpp.cols());  mat_boost.clear();  for(int i = 0; i < (int)mat_itpp.rows(); ++i){    for(int j = 0; j < (int)mat_itpp.cols(); ++j){      try{	mat_boost(i, j) = mat_itpp(i, j);      }catch(char *str){	cout << str << endl;      }    }  }  return mat_boost;}//k-means is prototype-based unsupervised classification algorithm.//"k" is the variable that contains the number of representation point.//"dm" is a prototype dataset.stl_dvvect kmeans(int const k, dmat *dm, int mode){	stl_dvvect center_of_cluster;		switch(mode){	case 1:choose_random_center(k, &center_of_cluster, dm);break;	case 2:choose_smart_center(k, &center_of_cluster, dm);break;	case 3:choose_ica_center(k, &center_of_cluster, dm);break;	default:choose_random_center(k, &center_of_cluster, dm);break;	}	classification(k, &center_of_cluster, dm);		return center_of_cluster;}void choose_random_center(int const k, stl_dvvect* center_of_cluster, dmat* const dm){	rnd_shuffle rs(dm->size1());	std::vector<int> rs_vector = rs.getshuffled();		for(int i = 0; i < k; ++i){		center_of_cluster->push_back(row(*dm, rs_vector.at(i)));	}}void choose_smart_center(int const k, stl_dvvect* center_of_cluster, dmat* const dm){  rnd_shuffle rs(dm->size1());  std::vector<int> rs_vector = rs.getshuffled();    center_of_cluster->push_back(row(*dm, rs_vector.at(0)));    for(int i = 1; i < k; ++i){    int target_index = 0;    double probability = DBL_MIN;    double sumD = 0.0, D[(int)dm->size1()];        for(int j = 0; j < (int)dm->size1();++j){      double min_dist = DBL_MAX;            for(int num = 0; num < (int)center_of_cluster->size(); ++num){	min_dist = fmin(min_dist, norm_2(center_of_cluster->at(num) - row(*dm, j)));      }      D[j] = min_dist;      sumD += D[j] * D[j];    }        for(int j = 0; j < (int)dm->size1(); ++j){      if(probability < fmax(probability, (D[j] * D[j]) / sumD)){	probability = (D[j] * D[j]) / sumD ;	target_index = j;      }    }    if(target_index >= 0 && target_index < (int)dm->size1()){      center_of_cluster->push_back(row(*dm, target_index));    }else{      cout << "error occured !\n" << endl;    }  }}void choose_ica_center(int const k, stl_dvvect* center_of_cluster, dmat* dm){  mat dm_itpp = boost_mat_2_itpp_mat(*dm);  Fast_ICA fastica(dm_itpp);    fastica.set_nrof_independent_components(k);  fastica.set_non_linearity(FICA_NONLIN_TANH);  fastica.set_approach(FICA_APPROACH_DEFL);  fastica.separate();  dmat dm_ICA = itpp_mat_2_boost_mat(fastica.get_independent_components());  for(int i = 0; i < (int)dm_ICA.size1(); ++i){    int min_index = 0;    double min_dist = DBL_MAX;    for(int cnt = 0; cnt < (int)dm->size1(); ++cnt){      if(fmin(min_dist, inner_prod(row(dm_ICA, i), trans(row(*dm, cnt))) / (norm_1(row(dm_ICA, i)) * norm_1(row(*dm, cnt)))) < min_dist){	min_dist = inner_prod(row(dm_ICA, i), trans(row(*dm, cnt))) / (norm_1(row(dm_ICA, i)) * norm_1(row(*dm, cnt)));	min_index = cnt;      }    }    center_of_cluster->push_back(row(*dm, min_index));  }}void classification(int const k, stl_dvvect* center_of_cluster, dmat* const dm){  bool change_class = false;  map<int, int> index_class_map;    //This part assign all datas to a nearest cluster.  while(true){    change_class = false;        for(int i = 0; i < (int)dm->size1(); ++i){      int class_num = -1;      double min_dist = DBL_MAX;            for(int j = 0; j <  k; ++j){	if(fmin(min_dist, norm_2(center_of_cluster->at(j) - row(*dm, i))) < min_dist){	  min_dist = norm_2(center_of_cluster->at(j) - row(*dm, i));	  class_num = j;	}      }            if(index_class_map.empty() || (unsigned int) index_class_map.size() < (unsigned int)dm->size1()){	index_class_map.insert(map<int, int>::value_type(i, class_num));	change_class = true;      }else{	if(index_class_map[i] != class_num){	  index_class_map[i] = class_num;	  change_class = true;	}      }    }        if(!change_class){      break;    }		    //Compute each center of clusters.     center_of_cluster->clear();    for(int i = 0; i < k; ++i){      int sumNum = 0;      boost_dvect sumC;      sumC.resize(dm->size2());            for(int j = 0; j < (int)dm->size1(); ++j){	if(index_class_map[j] == i){	  ++sumNum;	  sumC += row(*dm, j);	}      }      try{	if(sumNum > 0){	  center_of_cluster->push_back(sumC / (double)sumNum);	}else{	  center_of_cluster->push_back(center_of_cluster->at(0));	}      }catch(char *e){	cout << "Exception [k-means.hpp] L210 - 214 : " << e << endl;      }    }	  }}