%% Micro Expert System. %% Ian Frank, July 2001, updated May 2002%% (Based on original by Alison Cawsey)%% This is a very simple backward chaining rule-based expert system. %% Given a possible goal, it backward chains to find out if it is true.%% If it cannot prove a fact using rules, it will just ask the user.%% %% If it proves the goal, it prints a conclusion.%%%% Facts input by the  user are added to the program using assert/1. %% The userfact predicate must be dynamic for this to work in SICStus::- dynamic(userfact/2).% -------------------------------------------------------------------% NEW OPERATORS:- op(975, fx, if).:- op(950, xfy, then).:- op(925, xfy, and).% -------------------------------------------------------------------% EXPERT SYSTEM RULES (EXPERT KNOWLEDGE BASE)rule(if has_feathers(X) then bird(X), 0.9).rule(if bird(X) and small(X) then good_pet(X), 0.7).rule(if cute(X) then good_pet(X), 0.5).% -------------------------------------------------------------------% TEXT TEMPLATES FOR ENGLISH%% qtext/2: %% Simple template for English questions%% NOTE: If you don't define qtext for a predicate, it won't be%       asked to the user.qtext(bird(X), ['Is ', X, ' a bird?']).qtext(cute(X), ['Is ', X, ' cute?']).qtext(has_feathers(X), ['Does ', X, ' have feathers?']).qtext(small(X), ['Is ', X, ' small']).%atext/2: Template based translation into recommendations.  atext(good_pet(X), ['I suggest that ', X, ' would make a good pet.']).% ------------------------------------------------------------------%% MAIN EXPERT SYSTEM SHELL CODE%% prove(Goal)% Succeeds if the goal is proved true.%% Picks a goal, and uses bchain to find out if it is true.% If it is true, check_goal writes out a result. % If false, the base case prints out a failure message.%prove(Goal) :-  bchain(Goal, CF),!,                  % bchain to check if true.  atext(Goal, Text),               % get hold of appropriate text.  write_list(Text).                % write out the recommendationprove(_) :-   write_list(['The goal does not seem to be true.']).% bchain(Goal)%% Succeeds if Goal is true.% Uses rules, & facts supplied by user to do backward chaining.bchain(G1 and G2, CF):-                  % G1 and G1 are true if  bchain(G1, CF1),                        % G1 can be proved by backward chaining   bchain(G2, CF2),   !,  CF is max(CF1, CF2).                     % and G2 can be too.  bchain(Goal, CF) :-                      % Goal is true if its a fact  userfact(Goal, CF), ! .bchain(Goal, CF):-                       % Goal is true if  rule(if Preconditions then Goal, CF1),  % there's a rule concluding it  bchain(Preconditions, CF2), !,  CF is CF1 * CF2.          % and its Preconditions can be                                     % proved by backward chainingbchain(Goal, CF):-                       % Goal is true if  user_says_its_true(Goal, CF).          % user says its true.% user_says_its_true(Goal)%% True if there is some text to use to ask the user about it,% and when you ask the user they say yes.% Asserts the fact so that further rules can use it.user_says_its_true(Goal) :-  qtext(Goal, Text),  yesno(Text),  readcf(CF),  assert(userfact(Goal, CF)). % yesno(Text)%% First, prints out the Text.% Then asks user to input a character (y/n)% Succeeds if the user inputs 'y'.yesno(Text) :-  write_list(Text),  write_list(['(y/n)']),  get(X),  X =:= 121.% write_list(List)% % writes out each element of a list%write_list([]) :-  nl.write_list([H|T]) :-  write(H),  write_list(T). % readcf(CF)% % prints out a message and reads in input, until the input is a number.%readcf(CF) :-  repeat,  format("Please give a CF for your answer (must be a number)~n",[]),  read(CF),  number(CF),  !.